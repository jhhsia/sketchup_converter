<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
<title>SkpReader API Documentation</title> 
<link href="tabs.css" rel="stylesheet" type="text/css"> 
<link href="doxygen.css" rel="stylesheet" type="text/css"> 
</head><body> 
<table width="100%" border="0" cellpadding="0" cellspacing="2"> 
  <tbody> 
    <tr> 
      <td width="1%"><a href="http://code.google.com/labs/"><img src="http://code.google.com/images/codelabs_sm.png" alt="Go to Google Code Home" border="0" height="55" hspace="4" vspace="0" width="150" /></a></td> 
      <td><table border="0" cellpadding="2" cellspacing="0" width="100%"> 
        <tbody> 
          <tr> 
            <td style="background-color:#dcf6db;border-top:1px solid #090"><b><font size="+1">Google SketchUp SkpReader C++ API Documentation (<a href="http://code.google.com/labs/">Labs</a>)</font></b></td> 
          </tr> 
        </tbody> 
      </table></td> 
    </tr> 
  </tbody> 
</table> 
<br>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>WriteTexturesAndUVs.cpp</h1>  </div>
</div>
<div class="contents">
<p>This example demonstrates how to populate the texture writer with all the faces found in a model, how to write all the appropriate texture files, and how to generate UV coordinates corrected for perspective distortions. This is one of the most common pitfalls when using the SkpReader API.</p>
<p>Objects implementing the <a class="el" href="interface_i_skp_texture_writer.html" title="A utility class that will write out texture files.">ISkpTextureWriter</a> interface support the abilities to determine which image files are associated with a particular face, write those image files, and correct for perspective distortion.</p>
<p>This example is an abridged form of the SkpToXML exporter example code that comes with the SDK. It does not show how to handle inheritance of textures from component instances or groups to faces they contain. To see how that is done, see the SkpToXML exporter example.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="interface_i_skp_texture_writer.html" title="A utility class that will write out texture files.">ISkpTextureWriter</a> </dd>
<dd>
<a class="el" href="interface_i_skp_texture_writer2.html" title="An extension of the ISkpTextureWriter to support Groups.">ISkpTextureWriter2</a> </dd>
<dd>
<a class="el" href="interface_i_skp_application.html#a1232d2efd1fc5872d2763aa7c8c40d8e" title="A utility method that will create a texture writer.">ISkpApplication::CreateTextureWriter</a> </dd>
<dd>
<a class="el" href="interface_i_skp_face.html#aa80e8ca8f4ec92b3d3c8387faef0089c" title="Creates a UV helper for the face.">ISkpFace::GetUVHelper</a></dd></dl>
<div class="fragment"><pre class="fragment">
<span class="keywordtype">void</span> CXMLExporter::LoadAndWriteTextureFiles()
{
  HResult hr;

  <span class="comment">// Get the ISkpApplication from the ISkpDocument</span>
  CComPtr&lt;ISkpApplication&gt; pApp;
  hr = m_pDocument-&gt;get_Application(&amp;pApp);

  <span class="comment">// Get the ISkpTextureWriter2 interface from ISkpApplication.  You</span>
  <span class="comment">// first have to get the ISkpTextureWriter, then get the ISkpTextureWriter2</span>
  <span class="comment">// extension from that.</span>
  CComPtr&lt;ISkpTextureWriter&gt; pTW;
  hr = pApp-&gt;CreateTextureWriter(&amp;pTW);
  hr = pTW-&gt;QueryInterface(IID_ISkpTextureWriter2, (<span class="keywordtype">void</span>**)&amp;m_pTextureWriter);

  <span class="comment">// Get the top-level ISkpEntityProvider interface from the ISkpDocument, </span>
  <span class="comment">// which is the root component in the model</span>
  CComPtr&lt;ISkpEntityProvider&gt; pEntProvider;
  hr = m_pDocument-&gt;QueryInterface(IID_ISkpEntityProvider, (<span class="keywordtype">void</span>**) &amp;pEntProvider);

  <span class="comment">// Start recursing down the component hierarchy, loading the textures into</span>
  <span class="comment">// the ISkpTextureWriter2 along the way</span>
  LoadTexturesFromEntities(pEntProvider);

  <span class="comment">// Write out all the textures to a folder </span>
  std::string btextureDir = GetExportFolder();
  _bstr_t textDirBstr(btextureDir.c_str());
  hr = m_pTextureWriter-&gt;WriteAllTextures(textDirBstr, FALSE);
}


<span class="comment">// This loads the textures for all the faces in the ISkpEntityProvider.  It recursively</span>
<span class="comment">// calls itself for all the component instances, groups and images in the entity set</span>
<span class="comment">// so that we load textures for faces all the way down the component hierarchy.</span>
<span class="keywordtype">void</span> CXMLExporter::LoadTexturesFromEntities(CComPtr&lt;ISkpEntityProvider&gt; pEntProvider)
{
  HResult hr;
  <span class="keywordtype">long</span> nElements, i;

  <span class="comment">// Recurse through any component instances in this set of entities</span>
  CComPtr&lt;ISkpComponentInstances&gt; pInstances = NULL;
  hr = pEntProvider-&gt;get_ComponentInstances(&amp;pInstances);
  hr = pInstances-&gt;get_Count(&amp;nElements);

  <span class="keywordflow">for</span>(i=0; i&lt;nElements; i++)
  {
    <span class="comment">// Get the ISkpComponentInstance from the ISkpComponentInstances</span>
    CComPtr&lt;ISkpComponentInstance&gt; pInstance;
    hr = pInstances-&gt;get_Item(i, &amp;pInstance);

    <span class="comment">// Get the instance&#39;s component definition (ISkpComponentDefinition)</span>
    CComPtr&lt;ISkpComponentDefinition&gt; pDef;
    hr = pInstance-&gt;get_ComponentDefinition(&amp;pDef);

    <span class="comment">// Get the ISkpEntityProvider interface from the ISkpComponentDefinition</span>
    CComPtr&lt;ISkpEntityProvider&gt; pEntProvider;
    hr = pDef-&gt;QueryInterface(IID_ISkpEntityProvider, (<span class="keywordtype">void</span>**) &amp;pEntProvider);

    <span class="comment">// Recursively call this function</span>
    LoadTexturesFromEntities(pEntProvider);
  }

  <span class="comment">// Recurse through any groups in this set of entities</span>
  CComPtr&lt;ISkpGroups&gt; pGroups = NULL;
  hr = pEntProvider-&gt;get_Groups(&amp;pGroups);
  hr = pGroups-&gt;get_Count(&amp;nElements);

  <span class="keywordflow">for</span>(i=0; i&lt;nElements; i++)
  {
    <span class="comment">// Get the ISkpGroup from the ISkpGroups</span>
    CComPtr&lt;ISkpGroup&gt; pGroup;
    hr = pGroups-&gt;get_Item(i, &amp;pGroup);

    <span class="comment">// Get the ISkpEntityProvider interface from the ISkpGroup</span>
    CComPtr&lt;ISkpEntityProvider&gt; pEntProvider;
    hr = pGroup-&gt;QueryInterface(IID_ISkpEntityProvider, (<span class="keywordtype">void</span>**) &amp;pEntProvider);

    <span class="comment">// Recursively call this function</span>
    LoadTexturesFromEntities(pEntProvider);
  }

  <span class="comment">// Recurse through any images in this set of entities</span>
  CComPtr&lt;ISkpImages&gt; pImages = NULL;
  hr = pEntProvider-&gt;get_Images(&amp;pImages);
  hr = pImages-&gt;get_Count(&amp;nElements);

  <span class="keywordflow">for</span>(i=0; i&lt;nElements; i++)
  {
    <span class="comment">// Get the ISkpImage from the ISkpImages</span>
    CComPtr&lt;ISkpImage&gt; pImage;
    hr = pImages-&gt;get_Item(i, &amp;pImage);

    <span class="comment">// Get the ISkpEntityProvider interface from the ISkpImage</span>
    CComPtr&lt;ISkpEntityProvider&gt; pEntProvider;
    hr = pImage-&gt;QueryInterface(IID_ISkpEntityProvider, (<span class="keywordtype">void</span>**) &amp;pEntProvider);

    <span class="comment">// Recursively call this function</span>
    LoadTexturesFromEntities(pEntProvider);
  }

  <span class="comment">// Load all the textures applied to faces in this set of entities</span>
  CComPtr&lt;ISkpFaces&gt; pFaces = NULL;
  hr = pEntProvider-&gt;get_Faces(&amp;pFaces);
  hr = pFaces-&gt;get_Count(&amp;nElements);

  <span class="keywordflow">for</span>(i=0; i&lt;nElements; i++)
  {
    <span class="comment">// Get the ISkpFace from the ISkpFaces</span>
    CComPtr&lt;ISkpFace&gt; pFace;
    hr = pFaces-&gt;get_Item(i, &amp;pFace);

    <span class="comment">// Load the texture on the FRONT side of the face into the texture writer</span>
    <span class="keywordtype">long</span> handle = 0;
    hr = m_pTextureWriter-&gt;LoadFace(pFace, <span class="comment">/*bFront*/</span> <span class="keyword">true</span>, &amp;handle);

    <span class="comment">// Load the texture on the BACK side of the face into the texture writer</span>
    handle=0;
    hr = m_pTextureWriter-&gt;LoadFace(pFace, <span class="comment">/*bFront*/</span> <span class="keyword">false</span>, &amp;handle);
  }
}


<span class="comment">// Eventually, you&#39;ll be writing out the vertices of each face and will want the UV texture </span>
<span class="comment">// coordinates associated with each vertex.  This is an abridged version of the WriteFace() method</span>
<span class="comment">// in the SkpToXML exporter example.</span>
<span class="keywordtype">void</span> CXMLExporter::WriteFace(CComPtr&lt;ISkpFace&gt; pFace)
{
  HResult hr;

  <span class="comment">//------------------------------------------------------------------------------------------------</span>
  <span class="comment">// Determine which sides of this face have textures applied to them</span>

  BOOL bHasFrontTexture = <span class="keyword">false</span>;
  BOOL bHasBackTexture = <span class="keyword">false</span>;

  CComPtr&lt;ISkpMaterial&gt; pFrontMaterial = NULL;
  hr = pFace-&gt;get_FrontMaterial(pFrontMaterial);
  <span class="keywordflow">if</span> (pFrontMaterial)
  {
    hr = pFrontMaterial-&gt;get_IsTexture(&amp;bHasFrontTexture);
  }

  CComPtr&lt;ISkpMaterial&gt; pBackMaterial = NULL;
  hr = pFace-&gt;get_BackMaterial(pBackMaterial);
  <span class="keywordflow">if</span> (pBackMaterial)
  {
    hr = pBackMaterial-&gt;get_IsTexture(&amp;bHasBackTexture);
  }

  <span class="comment">//------------------------------------------------------------------------------------------------</span>
  <span class="comment">// Write out the texture file names for the front and back </span>
  <span class="keywordflow">if</span> (bHasFrontTexture)
  {
    <span class="comment">// Get the name of the texture file and write it out</span>
    <span class="keywordtype">long</span> texture_handle = 0;
    hr = m_pTextureWriter-&gt;GetTextureHandleFromFace(pFace, <span class="comment">/*bFront*/</span> TRUE, &amp;texture_handle)
    <span class="keywordflow">if</span>(texture_handle &gt; 0)
    {
      BSTR bstrName;
      <span class="comment">// from the handle, get the texture file name</span>
      hr = m_pTextureWriter-&gt;GetTextureFile(texture_handle, &amp;bstrName);

      <span class="comment">// ***** Write out the name of the front texture file here... ******</span>

      ::SysFreeString(bstrName);
    }
  }

  <span class="keywordflow">if</span> (bHasBackTexture)
  {
    <span class="comment">// Get the name of the texture file and write it out</span>
    <span class="keywordtype">long</span> texture_handle = 0;
    hr = m_pTextureWriter-&gt;GetTextureHandleFromFace(pFace, <span class="comment">/*bFront*/</span> FALSE, &amp;texture_handle)
    <span class="keywordflow">if</span>(texture_handle &gt; 0)
    {
      BSTR bstrName;
      <span class="comment">// from the handle, get the texture file name</span>
      hr = m_pTextureWriter-&gt;GetTextureFile(texture_handle, &amp;bstrName);

      <span class="comment">// ***** Write out the name of the back texture file here... ******</span>

      ::SysFreeString(bstrName);
    }
  }

  <span class="comment">//------------------------------------------------------------------------------------------------</span>
  <span class="comment">// If the face has a texture(s) applied to it, then create a UVHelper class so we can output the uv</span>
  <span class="comment">// coordinates at each vertex.</span>
  BOOL bHasTexture = bHasFrontTexture | bHasBackTexture;
  <span class="keywordflow">if</span> (bHasTexture)
  {
    <span class="comment">// You have to create this object from the ISkpTexureWriter to pass into the GetUVHelper method</span>
    <span class="comment">// later.  Not creating it as passing in NULL to GetUVHelper will cause your to crash.</span>
    CComPtr&lt;ISkpCorrectPerspective&gt; pCorrectPerspective;
    hr = m_pTextureWriter-&gt;QueryInterface(IID_ISkpCorrectPerspective, (<span class="keywordtype">void</span>**)&amp;pCorrectPerspective); 

    <span class="comment">// Get the ISkpUVHelper for this face</span>
    CComPtr&lt;ISkpUVHelper&gt; pUVHelper = NULL;
    hr = pFace-&gt;GetUVHelper(bHasFrontTexture, bHasBackTexture, pCorrectPerspective, &amp;pUVHelper);

    <span class="comment">// We&#39;re going to output the UV&#39;s for the vertices around the face&#39;s perimeter (outer loop) </span>
    <span class="comment">// in this example.</span>
    CComPtr&lt;ISkpLoop&gt; pLoop;
    hr = pFace-&gt;get_OuterLoop(&amp;pLoop);

    <span class="comment">// Get the vertices on the perimeter</span>
    CComPtr&lt;ISkpVertices&gt; pVerts;
    hr = pLoop-&gt;get_Vertices(&amp;pVerts);

    <span class="keywordtype">long</span> nVerts;
    hr = pVerts-&gt;get_Count(&amp;nVerts);

    <span class="comment">// Loop through the vertices</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i=0;i&lt;nVerts;i++)
    {
      CComPtr&lt;ISkpVertex&gt; pVert;
      hr = pVerts-&gt;get_Item(i, &amp;pVert);

      <span class="comment">// Get the position of the vertex - not this in the local coordinate space (LCS)</span>
      CComPtr&lt;ISkpPoint3d&gt; pSkpPoint;
      hr = pVert-&gt;get_Position(&amp;pSkpPoint);

      <span class="comment">// Transform the point into world coordinate space (WCS)</span>
      CPoint3d point(pSkpPoint);
      CPoint3d worldPoint = m_InheritanceManager.GetCurrentTransform() * point;

      <span class="keywordflow">if</span> (bHasFrontTexture)
      {     
        <span class="comment">// Get the uv coordinates of the front texture at this point</span>
        <span class="keywordtype">double</span> u, v, q;
        pUVHelper-&gt;GetFrontUVQ(worldPoint.X(), worldPoint.Y(), worldPoint.Z(), &amp;u, &amp;v, &amp;q);
        
        <span class="comment">// ***** Write out the UV coordinates for the front texture on this face at this vertex... *****</span>
      }

      <span class="keywordflow">if</span> (bHasBackTexture)
      {
        <span class="comment">// Get the uv coordinates of the back texture at this point</span>
        <span class="keywordtype">double</span> u, v, q;
        pUVHelper-&gt;GetBackUVQ(worldPoint.X(), worldPoint.Y(), worldPoint.Z(), &amp;u, &amp;v, &amp;q);
        
        <span class="comment">// ***** Write out the UV coordinates for the back texture on this face at this vertex... *****</span>
      }
    }
  }
}
</pre></div> </div>
</div>
<br>
<table width="100%" border="0" align="left" cellpadding="2" cellspacing="0"> 
  <tbody> 
    <tr> 
      <td width="100%"><div align="center"><font size="-1"><font color="#666666">&copy;2010 Google</font> - <a href="http://www.google.com/">Google Home</a> - <a href="http://www.google.com/about.html">About Google</a></font></div></td> 
    </tr> 
  </tbody> 
</table> 
<br>
</body>
</html>
